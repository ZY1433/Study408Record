# 散列表

## 基本概念

- **散列表（哈希表**，Hash Table）：是⼀种数据结构。特点是：可以**根据**数据元素的**关键字**，**计算出**它在散列表中的**存储地址**  
- **散列函数**（哈希函数）：Addr=H(key) 建⽴了**“关键字”→“存储地址”**的映射关系。
- **冲突（碰撞**）：在散列表中**插⼊⼀个数据元素时**，需要根据关键字的值确定其存储地址，若 该地址**已经存储了其他元素**，则称这种情况为“冲突（碰撞）”  
- **同义词**：若不同的关键字通过散列函数**映射到同⼀个存储地址**，则称它们为“同义词”



## 散列函数的构造要求

- 定义域**必须涵盖所有**可能出现的**关键字**。  
- 值域**不能超出**散列表的地址范围。 
- 尽可能减少冲突。散列函数计算出来的**地址应尽可能均匀分布**在整个地址空间。
- 散列**函数应尽量简单**，能够快速计算出任 意⼀个关键字对应的散列地址。



## 散列函数的构造方法



### 除留余数法(最常用)

$$
H(key)=key \% p
$$

要求**p是**最接近且**不大于**散列**表长**度的**素数**

这是因为使用素数会让地址分布的更均匀

适⽤场景：较为通⽤，只要关键字是整数即可



### 直接定址法

$$
H(key) = key 或 H(key) = a*key + b
$$

a和b是常数。这种⽅法计算最简单，且不会产⽣冲突。若关键字分布不连续，空位较多， 则会造成存储空间的浪费。

适⽤场景：**关键字分布基本连续**,比如连续的学号



### 数字分析法 

 观察关键字码，选取数码分布较为均匀的若⼲位作为散列地址

适⽤场景：**关键字集合已知**，且关键字的某⼏个数码位**分布均匀**



### 平⽅取中法

取关键字的平⽅值的中间⼏位作为散列地址。  具体取多少位要视实际情况⽽定。

这种⽅法得到的散列地址与关键字的每位都有关系，因此使得 散列地址分布⽐较均匀。 

适⽤场景：关键字的**每位取值都不够均匀**。



## 处理冲突的方法

### 拉链法

把**所有“同义词”存储在⼀个链表**中，也就是在每个位置都看作一个链表，有重复地址的关键字，把它插入同一个链表即可

#### 插入

如何在散列表（拉链法解决冲突）中插⼊⼀个新元素？ 

 Step 1：结合散列函数计算新元素的散列地址  

Step 2：将新元素插⼊散列地址对应的链表（可⽤头插法，也可⽤尾插法，默认头插）

#### 查找

先计算出地址，再遍历链表，直到查找成功或失败

**查找⻓度**——在查找运算中，需要**对⽐关键字的次数**称为查找⻓度

#### 删除

计算出地址，遍历链表查到将其删除即可



### 开放定址法

开放定址法是指表中可存放新表项的空闲地址即对它的同义词开放也向非同义词开放，其公式为：
$$
H_i(key)=(H(key)+d_i)\%m
$$
**H(key)**：原始的散列函数。

**d_i**：增量序列，也叫探查序列通常取决于冲突解决策略。

**m**：散列表的大小。

**i**：探查的次数。

i从0开始取到m-1，下面是四种增量序列构造的不同方法



1. **线性探测法**（Linear Probing）

   - 探查序列：
     $$
     d_i = i
     $$

   - 此时公式为
     $$
     H_i(key) = (H(key) + i) \% m
     $$

   - 每次冲突时向后探查一个位置。

   - 它无论如何都可以探测完所有地址

2. **二次探查**（Quadratic Probing）

   - 探查序列：
     $$
     d_i = {(-1)}^{i-1}i^2
     $$
     
   - 公式：
     $$
     H_i(key) = (H(key) + i^2) \% m
     $$
   - 每次冲突时向后和向前探查 i^2 个位置，有助于减少集聚现象。
   - 注意只有散列表长度为一个可以表示为4k+3的素数时，才能探测所有地址

3. **双散列探查**（Double Hashing）

1. - 探查序列：

   $$
   d_i = i \cdot H_2(key)
   $$

   其中 H2 是第二个散列函数。

   - 公式：
     $$
     H_i(key) = (H(key) + i \cdot H_2(key)) \% m
     $$
     

   - 使用两个不同的散列函数，可以更均匀地分布关键字。

   - 保证H2(key)的值和表长m互质，才能在m-1次探查完所有地址.所以一般会让m为素数，然后令
     $$
     H_2(key) = m - (key \% m)
     $$





4.**伪随机序列法**（Double Hashing）

​	探查序列由程序员人工设置



#### 开放定址法的查找和删除

##### 查找

查找比较简单，和插入类似，按照第i次冲突，加上dilai找到地址，若探查过程中遇到空，或者m-1次都没查到，则失败

##### 删除

开放定址法不能真的清空数据，否则在查找时可能会引起查找失败，应当设置标记位，删除后置为已删除。已删除的位置可以重新插入数据，但是查找不会引起查找失败。

## 性能分析

主要是计算平均查找长度ASL，需要计算对比关键字的次数，注意空指针不算对比，但是数组里为空的数据算对比



### 装填因子

装填因子定义为一个表的装满程度。
$$
\alpha = \frac{表中记录n}{散列表长度m}
$$
散列表的平均查找长度依赖于α，α越大，表越满，发生冲突的可能性越大，反之可能性会变小。

### 平均查找长度

在计算时要注意会**存在有些地址按照映射函数是找不到的**

比如说**H(key) = key % 7**，**表长为8**，采用线性探测，先插入6，再插入13，**13就会存到地址为7**的地方，**没有一个数字可以根据映射函数一次就找到7**，所以要只考虑前7(0-6)种情况的查找长度，不要算地址为7及其它映射不到的地方，而且在除的时候也是除7而不是除表长

#### 成功

成功需要考虑所有可能一次映射到，且存在(置为被删的也算存在)的节点个数

#### 失败

失败也需要考虑所有可能一次映射到的节点个数，空的也要算上
