---
typora-root-url: ..\..\一些截图
typora-copy-images-to: ..\..\一些截图
---

### B树

#### B树的特点

**m阶B**树就是平衡因子为0的m路平衡查找树

每个节点**至多**m-1个关键字，m个子树

若**根节点**不是叶节点(这里叶节点就是没有数据的空指针)，则至少一个节点，俩子树

除了根节点的所有**非叶节点**至少**m/2个子树**，即**m/2 -1个关键字**

![image-20240620164816093](/image-20240620164816093.png)

#### B树节点定义

```c
#include<stdio.h>
#include<stdlib.h>
#include<math.h>

#define ElmeType int
#define M 5

typedef struct BTNode {//M阶b树树节点
  ElmeType key[M-1];//关键字数量最多为M-1
  struct BTNode *child[M];//有M个叉，也就是M个子树
  int num;//当前节点有多少个关键字
}BTNode, *BTree;
```

其中key按从小到大升序排列

每个叉指针间隔排列在关键字中间，指向的子树所有关键字的值都在它左右两个关键字之间

#### 树高分析

对n个关键字、高度为h、阶数为m的b树

**关键字最多**时，让每个节点都有m-1个关键字，所有应该有(m-1)*(1+m+m^2...m^(h-1))个，节点根据等比数列化简

有
$$
n≤m^h−1
$$
即
$$
h \geq \log_m (n + 1)
$$


**关键字最少**时，因让每个节点关键字都尽量少，也就是根节点一个，其它节点(m/2 - 1)个

那么可知，第二层有2个节点，第三层有2(m/2)，第4层就有2(m/2)^2，注意这里是节点，不是关键字，不用-1，

所以h+1层就是2(m/2)^(h-1)，第**h+1层全是叶子节点**(这里的叶子节点是没有数据的空指针)

又因为叶子节点相当于所有可能的错误输出，所以n个节点就会分出**n+1个叶子节点**，所以有

$$
n+1 ≥ 2(m/2)^{h-1}
$$
即
$$
h \leq \log_{m/2} \left( \frac{n+1}{2} \right) + 1
$$


#### B树插入

插入只能向最底层进行插入

先找到要插入的位置，若插入后，该节点的关键字数少于m-1，则结束

若插入后，关键字超过m-1，则发生上溢出，需将第m/2个关键字移动到父节点的对应大小位置

它右边关键字形成一个新的节点，连接到它的右子树，若它加入父子树后父节点也溢出，重复上述操作，进行移动

若根节点溢出，则新建一个节点，把关键字移动上去，变为新的根节点即可

#### B树删除

##### **对非终端节点**

找到其直接前驱(左子树最右下)或直接后继(右子树最左下)替换被删除节点的值，然后转换为对其前驱或后继的删除，直到转换为对终端节点的删除

##### 对终端节点

若删除后，该节点剩余的关键字数**大于等于m/2-1，则无需修改**



若**小于m/2-1，观察它的左右兄弟**节点，若至少有一个超过m/2-1，则进行下列操作

先将其共同的父节点的那个关键字加入到被删节点中，然后让左兄弟最大的关键字(或右兄弟最小的关键字)去顶替那个父节点即可



若左右兄弟**都没有多余的关键字**，则**将被删的节点、左(或右)兄弟和他们共同的父节点的关键字合并**，成为一个新的节点，若**父节点被拿走后**，仍满足关键字数大于m/2-1，则无需操作了，**若小于了m/2-1**，则**重复以上操作**，先看兄弟，兄弟不够找父亲，直至所有节点都符合B树的条件，删除结束





### B+树

#### m阶B+树的基本概念

- 一个节点最多m个子树
- 非叶根节点至少两个子树，其它分支节点至少m/2个子树
- **子树个数和关键字个数相同**(这里和B树不同)
- 所有叶节点(在最底层的一块，最多可能包含m个关键字)包含全部关键字，并且包括其指向对应记录的指针，叶节点按照关键字大小进行排序，而且所有相邻叶节点有横向指针相连(支持顺序查找)
- 所有分支节点仅包含它指向节点里关键字的最大值和指向字节点的指针

![image-20240620160341045](/image-20240620160341045.png)

#### B+树查找

与分块查找类似，向下查找

注意不论成果与失败，**都要到叶子节点**才行



还可以使用p指针进行顺序查找



#### m阶B+树与m阶B树的异同

- B树n个关键字对应n+1个子树，而**B+树n个关键字对应n个子树**
- 对于**B树**，根节点可以有**[1，m-1]**个关键字，其他节点可以有**[m/2 - 1，m-1]**个关键字；而B+树根节点可以有**[1，m]**个关键字，其他节点可以有**[m/2，m]**个关键字
- 在B+树中，在分支节点出现过的数据在叶子节点还会出现，而B树只出现一次
- 在B+树中，分支节点起索引的作用，只保存字节点的最大关键字和指针，不保存关键字对应的记录的地址，对应记录在叶子节点中；而B树既包含了关键字，又包含了记录地址
- B+树支持顺序查找和随机查找而B树只支持随机查找

#### B+树的优点

由于系统是一个磁盘块一个磁盘块读的，将记录全部存放在叶子节点，有利于让每个节点存放更多索引，更容易让树变宽，减少查询次数
