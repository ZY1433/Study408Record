/*
  普通矩阵就直接建立N*N的二维数组即可，按二维数组的方式求地址就行
  注意，矩阵下标从11开始，而数组是00，注意转换
*/

// 对称矩阵：
/* 
  由于其关于主对角线对称位置的数据是相同的，所以只需要存储
  上三角区+主对角线或者下三角区+主对角线即可
  使用一维数组存储，一维数组长度为(1+N)*N/2 -1
  将矩阵下标转换为数组下标：
  行优先(存下三角区时，若i>=j,直接套，若i<j则交换再套，若存上三角则相反)：
  aij = a[(1+i)*i/2+j -1]
  列优先(存下三角区时，若i>=j,直接套，若i<j则交换再套，若存上三角则相反)：
  aij = a[(1+N)*N/2-(1+(N-j+1))*(N-j+1)/2 +i-j -1]

  不太好记，注意画图，画完就懂了
*/

// 三角矩阵：
/* 
  由于其下三角或上三角有一块存储的数据是相同的，所以只需要存储
  上剩下的区域和相同的值即可，和对称矩阵相似，只再最后加上那个常数
  使用一维数组存储，一维数组长度为(1+N)*N/2
  
  将矩阵下标转换为数组下标：
  行优先(存下三角区时，若i>=j,直接套，若i<j则输出a[(1+N)*N/2-1]，若存上三角则相反)：
  aij = a[(1+i)*i/2+j -1]
  列优先(存下三角区时，若i>=j,直接套，若i<j则a[(1+N)*N/2-1]，若存上三角则相反)：
  aij = a[(1+N)*N/2-(1+(N-j+1))*(N-j+1)/2 +i-j -1]
*/

// 三对角矩阵：
/* 
  也称带状矩阵，就是行号和列号的差值<=1的部分有值，其余部分全为0
  由于其只有第一行和最后一行有2个元素，其它行都是3个元素，所以
  使用一维数组存储，一维数组长度为3N-2
  
  将矩阵下标转换为数组下标：
  行优先(若|i-j|>1,则输出0,否则如下)：
  aij = a[i*3-4 + i+1-j]

  数组下标转矩阵下标
  行优先
  a[k] : 3(i-1)-1 < k+1 <= 3i-1
  j = k+1 - 3(i-1)+1 + i
*/

// 稀疏矩阵：
/* 
  就是非零元素远远少于0元素
  
  三元组法存储
  构建i、j、aij的结构体数组存储

  十字链表法
  每个节点是一个三元结构体和一个向下的指针已经一个向右的指针
  两个指针数组，一个是向右域，一个是向下域
  向右域存储每一行的第一个非零节点，该节点的右指针指向再右边的节点，以此类推
  向下域存储每一列的第一个非零节点，同向右域
*/