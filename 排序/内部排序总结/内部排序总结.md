# 内部排序算法比较



## 学习所有类别汇总

### 插入排序

#### 直接插入排序

#### 折半插入排序

#### 希尔排序

### 交换排序

#### 冒泡排序

#### 快速排序

### 选择排序

#### 简单选择排序

#### 堆排序

### 其它

#### 归并排序

#### 基数排序

#### 计数排序



## 时间复杂度

### O(n^2)

#### 直接插入(最好n，最差n^2，平均n^2)

#### 折半插入(最好n，最差n^2，平均n^2)

#### 希尔排序(与d有关，当d刚开始就取1，就退化成了直接插入算法)

#### 冒泡排序(最好n，最差n^2，平均n^2)

#### 快速排序(当初始序列为顺序或倒序时，会达到n^2)

#### 简单选择排序(一直n^2)



### O(nlog(n))

#### 快速排序(一般都是nlog(n),但是最差会退化到n^2)

#### 堆排序(都是nlog(n))

#### 归并排序(都是nlog(n))



### 可达O(n)

当本来序列就接近有序时

#### 直接插入(最好n，最差n^2，平均n^2)

#### 折半插入(最好n，最差n^2，平均n^2)

#### 希尔排序(与d有关，当d刚开始就取1，就退化成了直接插入算法)

#### 冒泡排序(最好n，最差n^2，平均n^2)

#### 基数排序与趟数、关键字可能取值还有n都有关系，n极大时趋近于O(n)

#### 计数排序与元素取值的上下限有关，时间复杂度为O(k),k是上下限差值

##  空间复杂度

### O(1)

#### 直接插入排序

#### 折半插入排序

#### 希尔排序

#### 冒泡排序

#### 简单选择排序

#### 堆排序

### O(log(n))

#### 快速排序(平均是log(n))

### O(n)

#### 归并排序

#### 快速排序(最坏能到n)

#### 基数排序为O(r)

的空间复杂度与关键字可能取值有关系，为O(r)，但一般r不会很大，比如对整数r就是10

#### 计数排序为O(k)

与元素取值的上下限有关，空间复杂度为O(k),k是上下限差值

## 稳定性

### 稳定

#### 直接插入排序

#### 折半插入排序

#### 冒泡排序

#### 归并排序

#### 基数排序



### 不稳定

#### 希尔排序

#### 快速排序

#### 简单选择排序

#### 堆排序



## 适用性

### 仅适用于顺序表

这里的适用不是不能用，但是对链表使用以下算法性能会完全退化，发挥不了优势

#### 折半插入排序

#### 希尔排序

#### 快速排序

#### 堆排序

#### 计数排序

### 可用于链表

#### 直接插入排序

#### 冒泡排序

#### 简单选择排序

#### 归并排序

#### 基数排序



## 过程特征

下面不一定包含所有排序，还是得具体分析

### 一趟排序可以确定一个元素最终位置

#### 快速排序(其实它一趟可能可以确定好几个基准元素)

#### 简单选择排序(一趟一个，在开头或结尾)

#### 冒泡排序(一趟一个，在开头或结尾)



### 一趟会产生部分有序

#### 希尔排序(每趟会让间隔d变有序)

#### 归并排序(每趟会让相邻区间合并有序)